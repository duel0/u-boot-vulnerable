name: "CodeQL Direct Query Analysis"

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  schedule:
    - cron: '0 8 * * 1'  # Esegui ogni lunedÃ¬ alle 8:00

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
      issues: write

    strategy:
      fail-fast: false
      matrix:
        language: [ 'cpp' ]

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    # IMPORTANTE: Prima creiamo la directory e il file della query
    - name: Create custom query
      run: |
        mkdir -p .github/codeql/custom-queries/cpp
        
        cat > .github/codeql/custom-queries/cpp/network-byte-swap-to-memcpy.ql << 'EOL'
        /** 
         * @name Network byte swap to memcpy size
         * @description Network byte-swapped data flows to memcpy size parameter without validation
         * @kind path-problem 
         */
        import cpp
        import semmle.code.cpp.dataflow.TaintTracking

        class NetworkByteSwap extends Expr {
          NetworkByteSwap() {
            exists(MacroInvocation invocation |
              invocation.getMacro().getName().regexpMatch("ntoh.*") and
              invocation.getExpr() = this
            )
          }
        }

        module MyConfig implements DataFlow::ConfigSig {

          predicate isSource(DataFlow::Node source) {
            exists(Expr e | source.asExpr() = e and e instanceof NetworkByteSwap)
          }

          predicate isSink(DataFlow::Node sink) {
            exists(FunctionCall call |
              call.getTarget().hasName("memcpy") and
              sink.asExpr() = call.getArgument(2) 
            )
          }

          // Input validation
          predicate isBarrier(DataFlow::Node node) {
            node.asExpr().getEnclosingStmt() instanceof IfStmt
          }
        }

        module MyTaint = TaintTracking::Global<MyConfig>;
        import MyTaint::PathGraph

        from MyTaint::PathNode source, MyTaint::PathNode sink
        where MyTaint::flowPath(source, sink)
        select sink, source, sink, "Network byte swap flows to memcpy"
        EOL

    # Inizializzazione di CodeQL con query diretta
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ matrix.language }}
        queries: .github/codeql/custom-queries/cpp
        build-mode: none

    # Esecuzione dell'analisi
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{matrix.language}}"
        output: sarif-results
    
    # Salvare i risultati come artefatti
    - name: Upload SARIF results
      uses: actions/upload-artifact@v4
      with:
        name: codeql-sarif-results
        path: sarif-results
        retention-days: 5
    
    # Forza l'upload dei risultati SARIF per assicurarsi che vengano visualizzati
    - name: Upload SARIF to GitHub
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: sarif-results/cpp.sarif

    # Debugging per verificare la presenza di pattern rilevanti
    - name: Debug potential matches
      run: |
        echo "=== Checking for potential matches ==="
        echo "Looking for ntoh/hton macro invocations:"
        grep -r "ntoh" --include="*.c" --include="*.h" . || echo "No ntoh found"
        
        echo "Looking for memcpy calls:"
        grep -r "memcpy" --include="*.c" --include="*.h" . || echo "No memcpy found"
        
        echo "Looking for potential vulnerable patterns (network data to memcpy):"
        grep -r -A 5 -B 5 "ntoh.*" --include="*.c" . | grep -i "memcpy" || echo "No direct matches found"
